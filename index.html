<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viral Cascade: AI Edition</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121218;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Fix for level select container */
        .level-select-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            width: 100%;
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            margin-top: 10px;
        }
        
        header {
            width: 100%;
            background-color: #2a2a36;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
        
        h1 {
            margin: 0;
            color: #4fc3f7;
            font-size: 1.8rem;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 1200px;
            height: 80vh;
            margin-top: 20px;
            position: relative;
        }
        
        .level-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            align-items: center;
        }
        
        .level-title {
            font-size: 1.4rem;
            color: #4fc3f7;
            display: flex;
            align-items: center;
        }
        
        .level-description {
            margin-left: 20px;
            font-size: 0.9rem;
            color: #a0a0a0;
            max-width: 300px;
        }
        
        .metrics {
            display: flex;
            gap: 20px;
        }
        
        .metric {
            background-color: #2a2a36;
            padding: 8px 15px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4fc3f7;
        }
        
        .network-container {
            flex: 1;
            background-color: #1d1d25;
            border-radius: 8px;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .network-canvas {
            width: 100%;
            height: 100%;
        }
        
        .control-panel {
            display: flex;
            margin-top: 20px;
            justify-content: space-between;
            background-color: #2a2a36;
            padding: 15px;
            border-radius: 8px;
        }
        
        .parameter-controls {
            display: flex;
            gap: 20px;
            flex: 1;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }
        
        .control-label {
            font-size: 0.9rem;
            color: #a0a0a0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .info-icon {
            cursor: help;
            color: #4fc3f7;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        select {
            background-color: #2a2a36;
            color: #e0e0e0;
            border: 1px solid #4fc3f7;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
        }
        
        .action-controls {
            display: flex;
            gap: 10px;
        }
        
        button {
            background-color: #4fc3f7;
            border: none;
            color: #121218;
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        button:hover {
            background-color: #81d4fa;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .tokens-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(42, 42, 54, 0.8);
            padding: 10px;
            border-radius: 4px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
            z-index: 100;
            max-width: 200px;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .card {
            background-color: #2a2a36;
            max-width: 60%;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        
        .card-title {
            color: #4fc3f7;
            margin-top: 0;
        }
        
        .card-content {
            line-height: 1.6;
        }
        
        .card-button {
            margin-top: 15px;
            background-color: #4fc3f7;
            border: none;
            color: #121218;
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }

        .activation-particle {
            position: absolute;
            background-color: #4fc3f7;
            border-radius: 50%;
            pointer-events: none;
        }

        .power-up-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(42, 42, 54, 0.8);
            padding: 10px;
            border-radius: 4px;
            min-width: 180px;
        }

        .power-up-button {
            background-color: #9c27b0;
            margin-bottom: 8px;
            display: block;
            width: 100%;
            text-align: left;
            position: relative;
        }

        .power-up-count {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .power-up-button:last-child {
            margin-bottom: 0;
        }

        .power-up-button:disabled {
            background-color: #4a4a5a;
            cursor: not-allowed;
        }
        
        .level-select-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            width: 80%;
            max-width: 1000px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px;
        }
        
        .level-card {
            background-color: #2a2a36;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
        }
        
        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .level-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .level-card.completed {
            border-color: #4caf50;
        }
        
        .level-card-title {
            color: #4fc3f7;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .level-card-description {
            font-size: 0.9rem;
            color: #cccccc;
            margin-bottom: 10px;
        }
        
        .level-card-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #a0a0a0;
        }
        
        .level-card-network {
            background-color: #1d1d25;
            height: 80px;
            border-radius: 4px;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
        }
        
        .node-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .mini-node {
            width: 10px;
            height: 10px;
            background-color: #4fc3f7;
            border-radius: 50%;
        }
        
        .connections {
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
        }
        
        .stats-panel {
            position: absolute;
            top: 60px;
            right: 10px;
            background-color: rgba(42, 42, 54, 0.8);
            padding: 10px;
            border-radius: 4px;
            width: 180px;
            display: none;
        }
        
        .stats-title {
            font-size: 0.9rem;
            color: #4fc3f7;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .stats-value {
            font-size: 0.8rem;
            margin-bottom: 3px;
            display: flex;
            justify-content: space-between;
        }
        
        .chart-container {
            width: 100%;
            height: 80px;
            margin-top: 10px;
            position: relative;
        }
        
        #accuracy-chart {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
        }
        
        .chart-label {
            position: absolute;
            font-size: 0.7rem;
            color: #a0a0a0;
            bottom: -15px;
            left: 0;
            right: 0;
            text-align: center;
        }

        .concept-popup {
            position: absolute;
            background-color: #323247;
            border-radius: 8px;
            padding: 15px;
            width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .concept-title {
            color: #4fc3f7;
            margin-top: 0;
            margin-bottom: 10px;
        }

        .concept-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .close-concept {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        .pulse-animation {
            animation: pulse 1.5s infinite ease-in-out;
        }

        .toggle-stats {
            position: absolute;
            top: 10px;
            right: 200px;
            background-color: rgba(42, 42, 54, 0.8);
            border: none;
            color: #4fc3f7;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        #loss-value {
            color: #ff5722;
        }

        #epoch-value {
            color: #ffeb3b;
        }

        #menu-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #4fc3f7;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 20;
        }
    </style>
</head>
<body>
    <header>
        <h1>Viral Cascade: AI Edition</h1>
        <button id="menu-button">☰</button>
    </header>
    
    <div class="game-container" id="game-view" style="display:none;">
        <div class="level-info">
            <div>
                <div class="level-title" id="level-title">Level 1: Classification Basics</div>
                <div class="level-description" id="level-description">Train your first neural network to classify simple binary patterns.</div>
            </div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">Accuracy</div>
                    <div class="metric-value" id="accuracy-value">0%</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Loss</div>
                    <div class="metric-value" id="loss-value">0.00</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Epoch</div>
                    <div class="metric-value" id="epoch-value">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Tokens</div>
                    <div class="metric-value" id="tokens-value">10</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Target</div>
                    <div class="metric-value" id="target-value">85%</div>
                </div>
            </div>
        </div>
        
        <div class="network-container">
            <canvas class="network-canvas" id="network-canvas"></canvas>
            <div class="tokens-container">
                <button id="training-token">Deploy Training Token</button>
            </div>
            <div class="power-up-container" id="power-up-container">
                <!-- Power-ups will be added dynamically -->
            </div>
            <button class="toggle-stats" id="toggle-stats">Show Stats</button>
            <div class="stats-panel" id="stats-panel">
                <div class="stats-title">Training Statistics</div>
                <div class="stats-value">
                    <span>Learning Rate:</span>
                    <span id="stat-learning-rate">0.5</span>
                </div>
                <div class="stats-value">
                    <span>Batch Size:</span>
                    <span id="stat-batch-size">32</span>
                </div>
                <div class="stats-value">
                    <span>Gradient Norm:</span>
                    <span id="stat-gradient">0.00</span>
                </div>
                <div class="stats-value">
                    <span>Weight Avg:</span>
                    <span id="stat-weight-avg">0.00</span>
                </div>
                <div class="chart-container">
                    <canvas id="accuracy-chart"></canvas>
                    <div class="chart-label">Accuracy Over Time</div>
                </div>
            </div>
            <div class="tooltip" id="tooltip"></div>
        </div>
        
        <div class="control-panel">
            <div class="parameter-controls" id="parameter-controls">
                <!-- Parameters will be added dynamically based on level -->
            </div>
            <div class="action-controls">
                <button id="reset-button">Reset Network</button>
                <button id="train-button">Run Training</button>
            </div>
        </div>

        <div class="concept-popup" id="concept-popup">
            <button class="close-concept" id="close-concept">×</button>
            <h3 class="concept-title" id="concept-title">Concept Title</h3>
            <div class="concept-content" id="concept-content">
                Concept explanation will appear here.
            </div>
        </div>
    </div>
    
    <div class="overlay" id="level-select-overlay">
        <div class="card" style="width: 80%; max-width: 1000px;">
            <h3 class="card-title">Select a Level</h3>
            <div class="level-select-container" id="level-select-container">
                <!-- Level cards will be added dynamically -->
            </div>
            <!-- Fallback button in case dynamic loading fails -->
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="selectLevel(0)" style="padding: 10px 20px; background-color: #4fc3f7; border: none; border-radius: 4px; color: #121218; font-weight: bold; cursor: pointer;">
                    Start Level 1
                </button>
            </div>
        </div>
    </div>
    
    <div class="overlay" id="tutorial-overlay" style="display:none;">
        <div class="card">
            <h3 class="card-title" id="tutorial-title">Welcome to Viral Cascade: AI Edition</h3>
            <div class="card-content" id="tutorial-content">
                In this game, you're a neural network trainer. Your goal is to adjust weights and parameters to achieve the target accuracy for each level.
                <br><br>
                <strong>How to play:</strong>
                <br>
                1. Deploy training tokens on nodes to influence them
                <br>
                2. Adjust parameters like learning rate and activation threshold
                <br>
                3. Run training to see how your network performs
                <br>
                4. Achieve the target accuracy to complete the level
            </div>
            <button class="card-button" id="tutorial-next">Start Training</button>
        </div>
    </div>

    <div class="overlay" id="level-complete-overlay" style="display:none;">
        <div class="card">
            <h3 class="card-title">Level Complete!</h3>
            <div class="card-content" id="level-complete-content">
                Congratulations! You've successfully trained your neural network to achieve the target accuracy.
                <br><br>
                <strong>Rewards:</strong>
                <br>
                <div id="rewards-list">
                    <!-- Rewards will be added dynamically -->
                </div>
            </div>
            <button class="card-button" id="level-complete-next">Next Level</button>
        </div>
    </div>

    <script>
        // Game data models
        const gameData = {
            player: {
                completedLevels: [],
                tokens: 10,
                powerUps: {
                    gradientBoost: 0,
                    regularization: 0,
                    batchNormalization: 0,
                    momentum: 0,
                    dataAugmentation: 0
                },
                currentLevel: 0,
                unlocked: [0]
            },
            
            levels: [
                {
                    id: 0,
                    name: "Level 1: Classification Basics",
                    description: "Train your first neural network to classify simple binary patterns.",
                    targetAccuracy: 85,
                    maxTokens: 10,
                    networkStructure: [4, 6, 2],
                    dataModel: {
                        type: "binary_classification",
                        classes: 2,
                        features: 4,
                        sampleSize: 100,
                        noiseLevel: 0.1
                    },
                    availableControls: [
                        { 
                            id: "learning-rate", 
                            name: "Learning Rate", 
                            type: "range", 
                            min: 0.01, 
                            max: 1, 
                            step: 0.01, 
                            value: 0.1,
                            description: "Controls how quickly the network updates weights. Higher values make bigger changes."
                        },
                        { 
                            id: "activation-fn", 
                            name: "Activation Function", 
                            type: "select", 
                            options: ["sigmoid", "relu", "tanh"],
                            value: "sigmoid",
                            description: "The function that determines how node values are calculated. Different functions have different properties."
                        },
                        { 
                            id: "batch-size", 
                            name: "Batch Size", 
                            type: "range", 
                            min: 1, 
                            max: 64, 
                            step: 1, 
                            value: 16,
                            description: "Number of samples processed before updating weights. Larger batches are more stable but slower to adapt."
                        }
                    ],
                    rewards: {
                        tokens: 20,
                        powerUps: {
                            gradientBoost: 1
                        }
                    },
                    tutorials: [
                        {
                            title: "Welcome to Classification",
                            content: "In this level, you'll train a neural network to classify data into two categories. This is one of the most common tasks in machine learning.<br><br>Your network has 4 input nodes (features), 6 hidden nodes (for processing), and 2 output nodes (classes).<br><br>Start by deploying training tokens on nodes you want to focus on, then adjust the parameters and run training.",
                        },
                        {
                            title: "Understanding Learning Rate",
                            content: "The <strong>Learning Rate</strong> controls how quickly your network adapts to the training data.<br><br>Higher values (>0.5) cause faster learning but might overshoot the optimal solution.<br><br>Lower values (<0.1) provide more stable but slower learning.<br><br>Try different values to see how it affects training!"
                        }
                    ]
                },
                {
                    id: 1,
                    name: "Level 2: Pattern Recognition",
                    description: "Train a network to recognize visual patterns with more complex hidden layer dynamics.",
                    targetAccuracy: 80,
                    maxTokens: 12,
                    networkStructure: [6, 8, 4],
                    dataModel: {
                        type: "multi_class",
                        classes: 4,
                        features: 6,
                        sampleSize: 150,
                        noiseLevel: 0.15
                    },
                    availableControls: [
                        { 
                            id: "learning-rate", 
                            name: "Learning Rate", 
                            type: "range", 
                            min: 0.01, 
                            max: 1, 
                            step: 0.01, 
                            value: 0.1,
                            description: "Controls how quickly the network updates weights. Higher values make bigger changes."
                        },
                        { 
                            id: "activation-fn", 
                            name: "Activation Function", 
                            type: "select", 
                            options: ["sigmoid", "relu", "tanh"],
                            value: "relu",
                            description: "The function that determines how node values are calculated. Different functions have different properties."
                        },
                        { 
                            id: "batch-size", 
                            name: "Batch Size", 
                            type: "range", 
                            min: 1, 
                            max: 64, 
                            step: 1, 
                            value: 16,
                            description: "Number of samples processed before updating weights. Larger batches are more stable but slower to adapt."
                        },
                        { 
                            id: "dropout-rate", 
                            name: "Dropout Rate", 
                            type: "range", 
                            min: 0, 
                            max: 0.5, 
                            step: 0.05, 
                            value: 0,
                            description: "Randomly deactivates nodes during training to prevent overfitting. Higher values provide more regularization."
                        }
                    ],
                    rewards: {
                        tokens: 25,
                        powerUps: {
                            regularization: 1
                        }
                    },
                    tutorials: [
                        {
                            title: "Pattern Recognition Challenge",
                            content: "This level focuses on recognizing visual patterns with more complex relationships. Your network needs to classify inputs into 4 different categories.<br><br>Notice the larger network structure, with 6 inputs, 8 hidden nodes, and 4 outputs.<br><br>You now have access to Dropout Rate, which helps prevent overfitting."
                        }
                    ]
                },
                {
                    id: 2,
                    name: "Level 3: Overfitting Challenge",
                    description: "Train a network on noisy data while avoiding overfitting to the training samples.",
                    targetAccuracy: 75,
                    maxTokens: 15,
                    networkStructure: [6, 10, 4],
                    dataModel: {
                        type: "noisy_classification",
                        classes: 4,
                        features: 6,
                        sampleSize: 200,
                        noiseLevel: 0.25,
                        testingSplit: 0.3
                    },
                    availableControls: [
                        { 
                            id: "learning-rate", 
                            name: "Learning Rate", 
                            type: "range", 
                            min: 0.001, 
                            max: 0.5, 
                            step: 0.001, 
                            value: 0.05,
                            description: "Controls how quickly the network updates weights. Higher values make bigger changes."
                        },
                        { 
                            id: "activation-fn", 
                            name: "Activation Function", 
                            type: "select", 
                            options: ["sigmoid", "relu", "tanh", "leaky_relu"],
                            value: "relu",
                            description: "The function that determines how node values are calculated. Different functions have different properties."
                        },
                        { 
                            id: "batch-size", 
                            name: "Batch Size", 
                            type: "range", 
                            min: 1, 
                            max: 64, 
                            step: 1, 
                            value: 32,
                            description: "Number of samples processed before updating weights. Larger batches are more stable but slower to adapt."
                        },
                        { 
                            id: "dropout-rate", 
                            name: "Dropout Rate", 
                            type: "range", 
                            min: 0, 
                            max: 0.5, 
                            step: 0.05, 
                            value: 0.2,
                            description: "Randomly deactivates nodes during training to prevent overfitting. Higher values provide more regularization."
                        },
                        { 
                            id: "l2-regularization", 
                            name: "L2 Regularization", 
                            type: "range", 
                            min: 0, 
                            max: 0.1, 
                            step: 0.005, 
                            value: 0.01,
                            description: "Penalizes large weights to prevent overfitting. Higher values result in smaller weights overall."
                        }
                    ],
                    rewards: {
                        tokens: 30,
                        powerUps: {
                            batchNormalization: 1
                        }
                    },
                    tutorials: [
                        {
                            title: "Overfitting Challenge",
                            content: "In this level, your data contains significant noise. The challenge is to build a model that generalizes well rather than memorizing the training examples.<br><br>Overfitting occurs when your model performs well on training data but poorly on new data.<br><br>Use regularization techniques like Dropout and L2 Regularization to combat overfitting."
                        }
                    ]
                },
                {
                    id: 3,
                    name: "Level 4: Multi-Class Classification",
                    description: "Train a deeper network for complex multi-class classification tasks.",
                    targetAccuracy: 70,
                    maxTokens: 20,
                    networkStructure: [8, 12, 6],
                    dataModel: {
                        type: "complex_multi_class",
                        classes: 6,
                        features: 8,
                        sampleSize: 300,
                        noiseLevel: 0.2
                    },
                    availableControls: [
                        { 
                            id: "learning-rate", 
                            name: "Learning Rate", 
                            type: "range", 
                            min: 0.001, 
                            max: 0.5, 
                            step: 0.001, 
                            value: 0.01,
                            description: "Controls how quickly the network updates weights. Higher values make bigger changes."
                        },
                        { 
                            id: "activation-fn", 
                            name: "Activation Function", 
                            type: "select", 
                            options: ["sigmoid", "relu", "tanh", "leaky_relu", "elu"],
                            value: "leaky_relu",
                            description: "The function that determines how node values are calculated. Different functions have different properties."
                        },
                        { 
                            id: "batch-size", 
                            name: "Batch Size", 
                            type: "range", 
                            min: 1, 
                            max: 128, 
                            step: 1, 
                            value: 64,
                            description: "Number of samples processed before updating weights. Larger batches are more stable but slower to adapt."
                        },
                        { 
                            id: "dropout-rate", 
                            name: "Dropout Rate", 
                            type: "range", 
                            min: 0, 
                            max: 0.5, 
                            step: 0.05, 
                            value: 0.2,
                            description: "Randomly deactivates nodes during training to prevent overfitting. Higher values provide more regularization."
                        },
                        { 
                            id: "l2-regularization", 
                            name: "L2 Regularization", 
                            type: "range", 
                            min: 0, 
                            max: 0.1, 
                            step: 0.005, 
                            value: 0.01,
                            description: "Penalizes large weights to prevent overfitting. Higher values result in smaller weights overall."
                        },
                        { 
                            id: "optimizer", 
                            name: "Optimizer", 
                            type: "select", 
                            options: ["sgd", "adam", "rmsprop"],
                            value: "adam",
                            description: "Algorithm used to update weights. Different optimizers have different properties and convergence rates."
                        }
                    ],
                    rewards: {
                        tokens: 40,
                        powerUps: {
                            momentum: 1
                        }
                    },
                    tutorials: [
                        {
                            title: "Multi-Class Classification",
                            content: "This level challenges you to classify inputs into 6 different categories. You're working with a larger network and more complex data relationships.<br><br>You now have access to different optimizer algorithms, which affect how weights are updated during training.<br><br>Adam is an adaptive optimizer that often performs well without much tuning, while SGD (Stochastic Gradient Descent) gives you more control but requires careful parameter selection."
                        }
                    ]
                },
                {
                    id: 4,
                    name: "Level 5: Adversarial Challenge",
                    description: "Train a robust network that can handle adversarial examples designed to fool classifiers.",
                    targetAccuracy: 65,
                    maxTokens: 25,
                    networkStructure: [8, 14, 8, 4],
                    dataModel: {
                        type: "adversarial",
                        classes: 4,
                        features: 8,
                        sampleSize: 400,
                        adversarialRatio: 0.2,
                        noiseLevel: 0.15
                    },
                    availableControls: [
                        { 
                            id: "learning-rate", 
                            name: "Learning Rate", 
                            type: "range", 
                            min: 0.0001, 
                            max: 0.1, 
                            step: 0.0001, 
                            value: 0.005,
                            description: "Controls how quickly the network updates weights. Higher values make bigger changes."
                        },
                        { 
                            id: "activation-fn", 
                            name: "Activation Function", 
                            type: "select", 
                            options: ["sigmoid", "relu", "tanh", "leaky_relu", "elu"],
                            value: "elu",
                            description: "The function that determines how node values are calculated. Different functions have different properties."
                        },
                        { 
                            id: "batch-size", 
                            name: "Batch Size", 
                            type: "range", 
                            min: 16, 
                            max: 256, 
                            step: 16, 
                            value: 128,
                            description: "Number of samples processed before updating weights. Larger batches are more stable but slower to adapt."
                        },
                        { 
                            id: "dropout-rate", 
                            name: "Dropout Rate", 
                            type: "range", 
                            min: 0, 
                            max: 0.5, 
                            step: 0.05, 
                            value: 0.3,
                            description: "Randomly deactivates nodes during training to prevent overfitting. Higher values provide more regularization."
                        },
                        { 
                            id: "l2-regularization", 
                            name: "L2 Regularization", 
                            type: "range", 
                            min: 0, 
                            max: 0.1, 
                            step: 0.005, 
                            value: 0.02,
                            description: "Penalizes large weights to prevent overfitting. Higher values result in smaller weights overall."
                        },
                        { 
                            id: "optimizer", 
                            name: "Optimizer", 
                            type: "select", 
                            options: ["sgd", "adam", "rmsprop"],
                            value: "adam",
                            description: "Algorithm used to update weights. Different optimizers have different properties and convergence rates."
                        },
                        { 
                            id: "adversarial-training", 
                            name: "Adversarial Training", 
                            type: "range", 
                            min: 0, 
                            max: 1, 
                            step: 0.1, 
                            value: 0.5,
                            description: "Percentage of adversarial examples to include in training. Higher values improve robustness but may reduce overall accuracy."
                        }
                    ],
                    rewards: {
                        tokens: 50,
                        powerUps: {
                            dataAugmentation: 1
                        }
                    },
                    tutorials: [
                        {
                            title: "Adversarial Challenge",
                            content: "In this advanced level, you'll face adversarial examples - inputs specifically designed to fool neural networks.<br><br>Your network has an additional hidden layer to help process these complex patterns. Notice the structure: 8 inputs, 14 hidden nodes, 8 more hidden nodes, and 4 outputs.<br><br>The Adversarial Training parameter controls how much your network learns from these tricky examples."
                        }
                    ]
                }
            ],

            powerUps: {
                gradientBoost: {
                    name: "Gradient Boost",
                    description: "Temporarily increases the effect of weight updates, helping convergence happen faster.",
                    effect: function(network) {
                        // Implementation in training function
                        return "Gradient updates boosted by 2x for this training cycle";
                    }
                },
                regularization: {
                    name: "Regularization Shield",
                    description: "Applies L2 regularization to prevent overfitting, even if not explicitly configured.",
                    effect: function(network) {
                        // Implementation in training function
                        return "Applied temporary L2 regularization to all weights";
                    }
                },
                batchNormalization: {
                    name: "Batch Normalization",
                    description: "Normalizes activations to improve training stability and convergence speed.",
                    effect: function(network) {
                        // Implementation in training function
                        return "Applied batch normalization to all layers";
                    }
                },
                momentum: {
                    name: "Momentum Accelerator",
                    description: "Adds momentum to weight updates, helping escape local minima.",
                    effect: function(network) {
                        // Implementation in training function
                        return "Added momentum to weight updates for this training cycle";
                    }
                },
                dataAugmentation: {
                    name: "Data Augmentation",
                    description: "Generates additional training examples by adding small variations to existing data.",
                    effect: function(network) {
                        // Implementation in training function
                        return "Generated augmented training data for this cycle";
                    }
                }
            },
            
            // Concepts for educational content
            concepts: {
                learningRate: {
                    title: "Learning Rate",
                    content: "The learning rate controls how quickly the network updates its weights during training. It's one of the most important hyperparameters to tune.<br><br><strong>Higher learning rates</strong> cause faster learning but may overshoot the optimal solution, leading to unstable training.<br><br><strong>Lower learning rates</strong> provide more stable learning but take longer to converge.<br><br>Finding the right learning rate is often a balancing act - too high and the network never converges, too low and training takes forever."
                },
                activationFunctions: {
                    title: "Activation Functions",
                    content: "Activation functions introduce non-linearity into neural networks, allowing them to learn complex patterns.<br><br><strong>Sigmoid:</strong> Maps values to range (0,1). Good for output layers in binary classification, but can cause vanishing gradients.<br><br><strong>ReLU:</strong> f(x) = max(0,x). Fast to compute and helps prevent vanishing gradients, but can cause 'dying neurons'.<br><br><strong>Tanh:</strong> Similar to sigmoid but maps to (-1,1). Generally performs better than sigmoid but still has vanishing gradient issues.<br><br><strong>Leaky ReLU:</strong> Like ReLU but allows small negative values, helping prevent dying neurons."
                },
                batchSize: {
                    title: "Batch Size",
                    content: "Batch size determines how many training examples are processed before the model weights are updated.<br><br><strong>Larger batches</strong> provide more stable gradient estimates but require more memory and may converge to poorer solutions.<br><br><strong>Smaller batches</strong> introduce more noise in the training process, which can help escape local minima, but can make training unstable.<br><br>A good batch size balances computational efficiency with generalization performance."
                },
                dropout: {
                    title: "Dropout",
                    content: "Dropout is a regularization technique that prevents overfitting by randomly deactivating a percentage of neurons during training.<br><br>This forces the network to develop redundant representations and not rely too heavily on any particular neuron, leading to better generalization.<br><br>Typical dropout rates range from 0.2 to 0.5 (meaning 20-50% of neurons are randomly dropped).<br><br>Dropout is only applied during training, not during inference/testing."
                },
                l2Regularization: {
                    title: "L2 Regularization",
                    content: "L2 regularization (also called weight decay) prevents overfitting by penalizing large weights.<br><br>It works by adding a term to the loss function that is proportional to the sum of squares of all weights.<br><br>This encourages the network to use smaller weights and distribute the importance across more features, which often leads to better generalization.<br><br>The regularization strength parameter controls how much to penalize large weights."
                },
                optimizers: {
                    title: "Optimizers",
                    content: "Optimizers determine how to update weights based on the computed gradients.<br><br><strong>SGD (Stochastic Gradient Descent):</strong> Simple but requires careful tuning of learning rate.<br><br><strong>Adam:</strong> Adaptive optimizer that maintains per-parameter learning rates, often works well out of the box.<br><br><strong>RMSprop:</strong> Adapts learning rates based on recent gradient magnitudes, good for recurrent networks.<br><br>Different optimizers work better for different problems, and their effectiveness often depends on proper hyperparameter settings."
                },
                adversarialTraining: {
                    title: "Adversarial Training",
                    content: "Adversarial examples are inputs specifically designed to fool neural networks, often by adding carefully crafted perturbations that are imperceptible to humans.<br><br>Adversarial training improves network robustness by incorporating these examples during training.<br><br>This technique forces the network to learn more robust features and decision boundaries, making it less susceptible to attacks and more reliable in real-world situations.<br><br>However, there's often a trade-off between robustness to adversarial examples and overall accuracy on clean data."
                }
            }
        };
        
        // Canvas setup
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('accuracy-chart');
        const chartCtx = chartCanvas.getContext('2d');
        
        // Game state variables
        let currentLevel;
        let network = {
            layers: [],
            weights: [],
            biases: [],
            activations: [],
            nodeFocus: [],
            gradients: {
                weights: [],
                biases: []
            },
            momentum: {
                weights: [],
                biases: []
            }
        };
        
        let activationFunctions = {
            sigmoid: {
                forward: function(x) {
                    return 1 / (1 + Math.exp(-x));
                },
                backward: function(x) {
                    const sigmoid = 1 / (1 + Math.exp(-x));
                    return sigmoid * (1 - sigmoid);
                }
            },
            relu: {
                forward: function(x) {
                    return Math.max(0, x);
                },
                backward: function(x) {
                    return x > 0 ? 1 : 0;
                }
            },
            tanh: {
                forward: function(x) {
                    return Math.tanh(x);
                },
                backward: function(x) {
                    const tanh = Math.tanh(x);
                    return 1 - tanh * tanh;
                }
            },
            leaky_relu: {
                forward: function(x) {
                    return x > 0 ? x : 0.01 * x;
                },
                backward: function(x) {
                    return x > 0 ? 1 : 0.01;
                }
            },
            elu: {
                forward: function(x) {
                    return x > 0 ? x : Math.exp(x) - 1;
                },
                backward: function(x) {
                    return x > 0 ? 1 : Math.exp(x);
                }
            }
        };
        
        let optimizers = {
            sgd: function(weights, biases, gradWeights, gradBiases, learningRate) {
                // Simple SGD update
                for (let l = 0; l < weights.length; l++) {
                    for (let i = 0; i < weights[l].length; i++) {
                        for (let j = 0; j < weights[l][i].length; j++) {
                            weights[l][i][j] -= learningRate * gradWeights[l][i][j];
                        }
                    }
                    
                    for (let i = 0; i < biases[l].length; i++) {
                        biases[l][i] -= learningRate * gradBiases[l][i];
                    }
                }
            },
            
            adam: function(weights, biases, gradWeights, gradBiases, learningRate, network, t = 1) {
                const beta1 = 0.9;
                const beta2 = 0.999;
                const epsilon = 1e-8;
                
                // Initialize momentum and velocity if not already present
                if (!network.adam) {
                    network.adam = {
                        m_weights: [],
                        v_weights: [],
                        m_biases: [],
                        v_biases: []
                    };
                    
                    for (let l = 0; l < weights.length; l++) {
                        const m_layer_weights = [];
                        const v_layer_weights = [];
                        
                        for (let i = 0; i < weights[l].length; i++) {
                            const m_node_weights = new Array(weights[l][i].length).fill(0);
                            const v_node_weights = new Array(weights[l][i].length).fill(0);
                            
                            m_layer_weights.push(m_node_weights);
                            v_layer_weights.push(v_node_weights);
                        }
                        
                        network.adam.m_weights.push(m_layer_weights);
                        network.adam.v_weights.push(v_layer_weights);
                        
                        network.adam.m_biases.push(new Array(biases[l].length).fill(0));
                        network.adam.v_biases.push(new Array(biases[l].length).fill(0));
                    }
                }
                
                // Update with Adam
                for (let l = 0; l < weights.length; l++) {
                    for (let i = 0; i < weights[l].length; i++) {
                        for (let j = 0; j < weights[l][i].length; j++) {
                            // Update biased first moment and second moment estimates
                            network.adam.m_weights[l][i][j] = beta1 * network.adam.m_weights[l][i][j] + (1 - beta1) * gradWeights[l][i][j];
                            network.adam.v_weights[l][i][j] = beta2 * network.adam.v_weights[l][i][j] + (1 - beta2) * gradWeights[l][i][j] * gradWeights[l][i][j];
                            
                            // Compute bias-corrected first moment and second moment estimates
                            const m_corrected = network.adam.m_weights[l][i][j] / (1 - Math.pow(beta1, t));
                            const v_corrected = network.adam.v_weights[l][i][j] / (1 - Math.pow(beta2, t));
                            
                            // Update weight
                            weights[l][i][j] -= learningRate * m_corrected / (Math.sqrt(v_corrected) + epsilon);
                        }
                    }
                    
                    for (let i = 0; i < biases[l].length; i++) {
                        // Update biased first moment and second moment estimates
                        network.adam.m_biases[l][i] = beta1 * network.adam.m_biases[l][i] + (1 - beta1) * gradBiases[l][i];
                        network.adam.v_biases[l][i] = beta2 * network.adam.v_biases[l][i] + (1 - beta2) * gradBiases[l][i] * gradBiases[l][i];
                        
                        // Compute bias-corrected first moment and second moment estimates
                        const m_corrected = network.adam.m_biases[l][i] / (1 - Math.pow(beta1, t));
                        const v_corrected = network.adam.v_biases[l][i] / (1 - Math.pow(beta2, t));
                        
                        // Update bias
                        biases[l][i] -= learningRate * m_corrected / (Math.sqrt(v_corrected) + epsilon);
                    }
                }
            },
            
            rmsprop: function(weights, biases, gradWeights, gradBiases, learningRate, network) {
                const decayRate = 0.9;
                const epsilon = 1e-8;
                
                // Initialize cache for RMSprop if not already present
                if (!network.rmsprop) {
                    network.rmsprop = {
                        cache_weights: [],
                        cache_biases: []
                    };
                    
                    for (let l = 0; l < weights.length; l++) {
                        const cache_layer_weights = [];
                        
                        for (let i = 0; i < weights[l].length; i++) {
                            const cache_node_weights = new Array(weights[l][i].length).fill(0);
                            cache_layer_weights.push(cache_node_weights);
                        }
                        
                        network.rmsprop.cache_weights.push(cache_layer_weights);
                        network.rmsprop.cache_biases.push(new Array(biases[l].length).fill(0));
                    }
                }
                
                // Update with RMSprop
                for (let l = 0; l < weights.length; l++) {
                    for (let i = 0; i < weights[l].length; i++) {
                        for (let j = 0; j < weights[l][i].length; j++) {
                            // Update cache
                            network.rmsprop.cache_weights[l][i][j] = decayRate * network.rmsprop.cache_weights[l][i][j] + 
                                                                      (1 - decayRate) * gradWeights[l][i][j] * gradWeights[l][i][j];
                            
                            // Update weight
                            weights[l][i][j] -= learningRate * gradWeights[l][i][j] / 
                                               (Math.sqrt(network.rmsprop.cache_weights[l][i][j]) + epsilon);
                        }
                    }
                    
                    for (let i = 0; i < biases[l].length; i++) {
                        // Update cache
                        network.rmsprop.cache_biases[l][i] = decayRate * network.rmsprop.cache_biases[l][i] + 
                                                            (1 - decayRate) * gradBiases[l][i] * gradBiases[l][i];
                        
                        // Update bias
                        biases[l][i] -= learningRate * gradBiases[l][i] / 
                                        (Math.sqrt(network.rmsprop.cache_biases[l][i]) + epsilon);
                    }
                }
            }
        };
        
        // Training data and parameters
        let trainingData = [];
        let validationData = [];
        let accuracy = 0;
        let loss = 0;
        let epoch = 0;
        let tokensLeft = 10;
        let targetAccuracy = 85;
        let accuracyHistory = [];
        let lossHistory = [];
        let levelComplete = false;
        let activePowerUps = {};
        
        // Animation variables
        let particles = [];
        let isTraining = false;
        let trainingInterval;
        let frameId;
        
        // Initialize level selection
        function initLevelSelection() {
            const container = document.getElementById('level-select-container');
            if (!container) {
                console.error('Level select container not found');
                return;
            }
            
            container.innerHTML = '';
            console.log('Initializing level selection with', gameData.levels.length, 'levels');
            
            gameData.levels.forEach((level, index) => {
                const isUnlocked = gameData.player.unlocked.includes(level.id);
                const isCompleted = gameData.player.completedLevels.includes(level.id);
                
                const levelCard = document.createElement('div');
                levelCard.className = `level-card ${isCompleted ? 'completed' : ''} ${!isUnlocked ? 'locked' : ''}`;
                
                if (isUnlocked) {
                    levelCard.onclick = () => selectLevel(level.id);
                }
                
                const networkStructure = level.networkStructure;
                
                levelCard.innerHTML = `
                    <h4 class="level-card-title">${level.name}</h4>
                    <div class="level-card-description">${level.description}</div>
                    <div class="level-card-network">
                        ${generateMiniNetworkHTML(networkStructure)}
                    </div>
                    <div class="level-card-details">
                        <span>Target: ${level.targetAccuracy}%</span>
                        <span>${isCompleted ? 'Completed ✓' : (isUnlocked ? 'Available' : 'Locked 🔒')}</span>
                    </div>
                `;
                
                container.appendChild(levelCard);
                console.log('Added level card:', level.name);
            });
        }
        
        // Generate mini network visualization for level cards
        function generateMiniNetworkHTML(layerSizes) {
            let html = '';
            
            for (let i = 0; i < layerSizes.length; i++) {
                const nodeCount = layerSizes[i];
                
                // Create node group
                html += `<div class="node-group">`;
                
                // Add nodes (limit display to 5 max for visual clarity)
                const displayCount = Math.min(nodeCount, 5);
                for (let j = 0; j < displayCount; j++) {
                    html += `<div class="mini-node"></div>`;
                }
                
                // Add indicator for more nodes if needed
                if (nodeCount > 5) {
                    html += `<div style="font-size: 0.7rem; color: #a0a0a0;">+${nodeCount - 5}</div>`;
                }
                
                html += `</div>`;
                
                // Add connections between layers
                if (i < layerSizes.length - 1) {
                    html += `<div class="connections">
                        <svg width="20" height="40">
                            <line x1="0" y1="20" x2="20" y2="20" stroke="#4fc3f7" stroke-width="1" />
                        </svg>
                    </div>`;
                }
            }
            
            return html;
        }
        
        // Select level and initialize game
        function selectLevel(levelId) {
            gameData.player.currentLevel = levelId;
            currentLevel = gameData.levels.find(level => level.id === levelId);
            
            document.getElementById('level-select-overlay').style.display = 'none';
            document.getElementById('game-view').style.display = 'flex';
            
            // Show tutorial for first-time level visit
            if (!gameData.player.completedLevels.includes(levelId)) {
                showTutorial(0); // Show first tutorial for this level
            } else {
                initializeLevel();
            }
        }
        
        // Show tutorial for current level
        function showTutorial(tutorialIndex) {
            const tutorials = currentLevel.tutorials;
            
            if (tutorials && tutorials.length > 0 && tutorialIndex < tutorials.length) {
                const tutorial = tutorials[tutorialIndex];
                
                document.getElementById('tutorial-title').textContent = tutorial.title;
                document.getElementById('tutorial-content').innerHTML = tutorial.content;
                
                // Set up button for next tutorial or start game
                const nextButton = document.getElementById('tutorial-next');
                
                if (tutorialIndex < tutorials.length - 1) {
                    nextButton.textContent = "Next";
                    nextButton.onclick = () => showTutorial(tutorialIndex + 1);
                } else {
                    nextButton.textContent = "Start Training";
                    nextButton.onclick = () => {
                        document.getElementById('tutorial-overlay').style.display = 'none';
                        initializeLevel();
                    };
                }
                
                document.getElementById('tutorial-overlay').style.display = 'flex';
            } else {
                document.getElementById('tutorial-overlay').style.display = 'none';
                initializeLevel();
            }
        }
        
        // Initialize level parameters and network
        function initializeLevel() {
            // Reset game state
            levelComplete = false;
            tokensLeft = currentLevel.maxTokens;
            accuracy = 0;
            loss = 0;
            epoch = 0;
            accuracyHistory = [];
            lossHistory = [];
            activePowerUps = {};
            
            // Update UI
            document.getElementById('level-title').textContent = currentLevel.name;
            document.getElementById('level-description').textContent = currentLevel.description;
            document.getElementById('accuracy-value').textContent = accuracy + '%';
            document.getElementById('loss-value').textContent = loss.toFixed(2);
            document.getElementById('epoch-value').textContent = epoch;
            document.getElementById('tokens-value').textContent = tokensLeft;
            document.getElementById('target-value').textContent = currentLevel.targetAccuracy + '%';
            targetAccuracy = currentLevel.targetAccuracy;
            
            // Initialize control panel
            initializeControls();
            
            // Initialize network
            initializeNetwork();
            
            // Update power-ups
            updatePowerUps();
            
            // Generate training data
            generateTrainingData();
            
            // Initialize stats panel
            document.getElementById('stats-panel').style.display = 'none';
            document.getElementById('toggle-stats').textContent = 'Show Stats';
            updateStatsPanel();
            
            // Start animation loop
            startAnimation();
        }
        
        // Initialize parameter controls based on level
        function initializeControls() {
            const controlsContainer = document.getElementById('parameter-controls');
            controlsContainer.innerHTML = '';
            
            currentLevel.availableControls.forEach(control => {
                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';
                
                const controlLabel = document.createElement('div');
                controlLabel.className = 'control-label';
                controlLabel.innerHTML = control.name + 
                    `<span class="info-icon" data-concept="${control.id}">ⓘ</span>`;
                
                controlGroup.appendChild(controlLabel);
                
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'slider-container';
                
                if (control.type === 'range') {
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.id = control.id;
                    slider.min = control.min;
                    slider.max = control.max;
                    slider.step = control.step;
                    slider.value = control.value;
                    
                    const valueDisplay = document.createElement('span');
                    valueDisplay.id = control.id + '-value';
                    valueDisplay.textContent = control.value;
                    
                    slider.addEventListener('input', (e) => {
                        valueDisplay.textContent = parseFloat(e.target.value).toFixed(
                            control.step < 0.01 ? 4 : (control.step < 0.1 ? 2 : 1)
                        );
                    });
                    
                    sliderContainer.appendChild(slider);
                    sliderContainer.appendChild(valueDisplay);
                } else if (control.type === 'select') {
                    const select = document.createElement('select');
                    select.id = control.id;
                    
                    control.options.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1);
                        if (option === control.value) {
                            optionElement.selected = true;
                        }
                        select.appendChild(optionElement);
                    });
                    
                    sliderContainer.appendChild(select);
                }
                
                controlGroup.appendChild(sliderContainer);
                controlsContainer.appendChild(controlGroup);
            });
            
            // Add event listeners for info buttons
            document.querySelectorAll('.info-icon').forEach(icon => {
                icon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const conceptId = e.target.getAttribute('data-concept');
                    showConceptInfo(conceptId);
                });
            });
        }
        
        // Show concept information popup
        function showConceptInfo(conceptId) {
            let conceptKey = conceptId;
            
            // Map control IDs to concept keys
            const conceptMap = {
                'learning-rate': 'learningRate',
                'activation-fn': 'activationFunctions',
                'batch-size': 'batchSize',
                'dropout-rate': 'dropout',
                'l2-regularization': 'l2Regularization',
                'optimizer': 'optimizers',
                'adversarial-training': 'adversarialTraining'
            };
            
            if (conceptMap[conceptId]) {
                conceptKey = conceptMap[conceptId];
            }
            
            const concept = gameData.concepts[conceptKey];
            
            if (concept) {
                document.getElementById('concept-title').textContent = concept.title;
                document.getElementById('concept-content').innerHTML = concept.content;
                
                const popup = document.getElementById('concept-popup');
                
                // Position near the clicked icon if possible
                const icon = document.querySelector(`[data-concept="${conceptId}"]`);
                if (icon) {
                    const rect = icon.getBoundingClientRect();
                    popup.style.top = (rect.bottom + 10) + 'px';
                    popup.style.left = rect.left + 'px';
                }
                
                popup.style.display = 'block';
                
                // Close when clicking elsewhere
                document.addEventListener('click', closeConceptOnClick);
            }
        }
        
        // Close concept popup when clicking outside
        function closeConceptOnClick(e) {
            const popup = document.getElementById('concept-popup');
            const closeButton = document.getElementById('close-concept');
            
            if (!popup.contains(e.target) || e.target === closeButton) {
                popup.style.display = 'none';
                document.removeEventListener('click', closeConceptOnClick);
            }
        }
        
        // Initialize close button for concept popup
        document.getElementById('close-concept').addEventListener('click', () => {
            document.getElementById('concept-popup').style.display = 'none';
            document.removeEventListener('click', closeConceptOnClick);
        });
        
        // Initialize network based on level configuration
        function initializeNetwork() {
            const structure = currentLevel.networkStructure;
            
            // Initialize network structure
            network.layers = [];
            for (let i = 0; i < structure.length; i++) {
                network.layers.push({
                    size: structure[i],
                    positions: []
                });
            }
            
            // Initialize weights, biases, and activations
            network.weights = [];
            network.biases = [];
            network.activations = [];
            network.preActivations = [];
            network.nodeFocus = [];
            network.gradients.weights = [];
            network.gradients.biases = [];
            network.momentum.weights = [];
            network.momentum.biases = [];
            
            // Initialize all activations arrays
            for (let l = 0; l < network.layers.length; l++) {
                const layerSize = network.layers[l].size;
                
                // Initialize activations for this layer
                network.activations.push(new Array(layerSize).fill(0));
                network.preActivations.push(new Array(layerSize).fill(0));
                network.nodeFocus.push(new Array(layerSize).fill(false));
                
                // Initialize biases for all but input layer
                if (l > 0) {
                    // Random biases between -0.1 and 0.1
                    const layerBiases = Array.from({ length: layerSize }, () => Math.random() * 0.2 - 0.1);
                    network.biases.push(layerBiases);
                    
                    // Initialize bias gradients
                    network.gradients.biases.push(new Array(layerSize).fill(0));
                    network.momentum.biases.push(new Array(layerSize).fill(0));
                }
            }
            
            // Initialize weights between layers
            for (let l = 0; l < network.layers.length - 1; l++) {
                const currentLayerSize = network.layers[l].size;
                const nextLayerSize = network.layers[l + 1].size;
                
                const layerWeights = [];
                const layerGradients = [];
                const layerMomentum = [];
                
                for (let i = 0; i < currentLayerSize; i++) {
                    const nodeWeights = [];
                    const nodeGradients = [];
                    const nodeMomentum = [];
                    
                    for (let j = 0; j < nextLayerSize; j++) {
                        // Xavier/Glorot initialization for better initial weights
                        const scale = Math.sqrt(2.0 / (currentLayerSize + nextLayerSize));
                        nodeWeights.push((Math.random() * 2 - 1) * scale);
                        nodeGradients.push(0);
                        nodeMomentum.push(0);
                    }
                    
                    layerWeights.push(nodeWeights);
                    layerGradients.push(nodeGradients);
                    layerMomentum.push(nodeMomentum);
                }
                
                network.weights.push(layerWeights);
                network.gradients.weights.push(layerGradients);
                network.momentum.weights.push(layerMomentum);
            }
            
            // Calculate node positions for visualization
            calculateNodePositions();
        }
        
        // Update power-ups display
        function updatePowerUps() {
            const container = document.getElementById('power-up-container');
            container.innerHTML = '';
            
            // Add power-up buttons for each available power-up
            Object.keys(gameData.player.powerUps).forEach(powerUpId => {
                const count = gameData.player.powerUps[powerUpId];
                
                if (count > 0) {
                    const powerUp = gameData.powerUps[powerUpId];
                    
                    const button = document.createElement('button');
                    button.className = 'power-up-button';
                    button.id = `power-up-${powerUpId}`;
                    button.innerHTML = `${powerUp.name} <span class="power-up-count">${count}</span>`;
                    button.title = powerUp.description;
                    
                    button.addEventListener('click', () => activatePowerUp(powerUpId));
                    
                    container.appendChild(button);
                }
            });
        }
        
        // Activate a power-up
        function activatePowerUp(powerUpId) {
            if (gameData.player.powerUps[powerUpId] > 0 && !activePowerUps[powerUpId]) {
                // Decrease count
                gameData.player.powerUps[powerUpId]--;
                
                // Mark as active
                activePowerUps[powerUpId] = true;
                
                // Visual effect
                const button = document.getElementById(`power-up-${powerUpId}`);
                button.classList.add('pulse-animation');
                
                // Update UI
                updatePowerUps();
                
                // Apply effect (actual implementation in training)
                const effect = gameData.powerUps[powerUpId].effect(network);
                
                // Show effect as tooltip
                const tooltip = document.getElementById('tooltip');
                tooltip.innerHTML = `<div><strong>${gameData.powerUps[powerUpId].name} Activated!</strong></div><div>${effect}</div>`;
                tooltip.style.display = 'block';
                tooltip.style.left = (canvas.width / 2) + 'px';
                tooltip.style.top = (canvas.height / 2) + 'px';
                
                // Hide tooltip after delay
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 3000);
            }
        }
        
        // Generate training data based on level data model
        function generateTrainingData() {
            const dataModel = currentLevel.dataModel;
            trainingData = [];
            validationData = [];
            
            const totalSamples = dataModel.sampleSize;
            const validationSplit = dataModel.testingSplit || 0.2;
            const trainSamples = Math.floor(totalSamples * (1 - validationSplit));
            const valSamples = totalSamples - trainSamples;
            
            switch (dataModel.type) {
                case 'binary_classification':
                    generateBinaryClassificationData(trainSamples, valSamples, dataModel);
                    break;
                case 'multi_class':
                    generateMultiClassData(trainSamples, valSamples, dataModel);
                    break;
                case 'noisy_classification':
                    generateNoisyClassificationData(trainSamples, valSamples, dataModel);
                    break;
                case 'complex_multi_class':
                    generateComplexMultiClassData(trainSamples, valSamples, dataModel);
                    break;
                case 'adversarial':
                    generateAdversarialData(trainSamples, valSamples, dataModel);
                    break;
                default:
                    generateBinaryClassificationData(trainSamples, valSamples, dataModel);
            }
        }
        
        // Generate binary classification data
        function generateBinaryClassificationData(trainSamples, valSamples, dataModel) {
            const features = dataModel.features;
            const noiseLevel = dataModel.noiseLevel || 0.1;
            
            // Generate training data
            for (let i = 0; i < trainSamples; i++) {
                // Random classification: 0 or 1
                const classLabel = Math.floor(Math.random() * 2);
                
                // Generate features with pattern related to class
                const input = [];
                for (let j = 0; j < features; j++) {
                    // Add pattern: even features are higher for class 1, odd features higher for class 0
                    let featureValue = 0;
                    if (j % 2 === classLabel) {
                        featureValue = 0.7 + Math.random() * 0.3;
                    } else {
                        featureValue = Math.random() * 0.3;
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue)); // Clamp to [0,1]
                    
                    input.push(featureValue);
                }
                
                // Create one-hot encoded output
                const output = [0, 0];
                output[classLabel] = 1;
                
                trainingData.push({ input, output });
            }
            
            // Generate validation data
            for (let i = 0; i < valSamples; i++) {
                const classLabel = Math.floor(Math.random() * 2);
                const input = [];
                
                for (let j = 0; j < features; j++) {
                    let featureValue = 0;
                    if (j % 2 === classLabel) {
                        featureValue = 0.7 + Math.random() * 0.3;
                    } else {
                        featureValue = Math.random() * 0.3;
                    }
                    
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                const output = [0, 0];
                output[classLabel] = 1;
                
                validationData.push({ input, output });
            }
        }
        
        // Generate multi-class classification data
        function generateMultiClassData(trainSamples, valSamples, dataModel) {
            const features = dataModel.features;
            const classes = dataModel.classes;
            const noiseLevel = dataModel.noiseLevel || 0.15;
            
            // Generate training data
            for (let i = 0; i < trainSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                // Generate features with more complex pattern
                for (let j = 0; j < features; j++) {
                    // Feature pattern: value depends on class and feature index
                    let featureValue = 0;
                    
                    // Each class has a distinct pattern of high/low features
                    if ((j + classLabel) % classes === 0) {
                        featureValue = 0.8 + Math.random() * 0.2; // High
                    } else if ((j + classLabel) % classes === 1) {
                        featureValue = 0.6 + Math.random() * 0.2; // Medium-high
                    } else if ((j + classLabel) % classes === 2) {
                        featureValue = 0.3 + Math.random() * 0.2; // Medium-low
                    } else {
                        featureValue = Math.random() * 0.2; // Low
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                // Create one-hot encoded output
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                trainingData.push({ input, output });
            }
            
            // Generate validation data
            for (let i = 0; i < valSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                for (let j = 0; j < features; j++) {
                    let featureValue = 0;
                    
                    if ((j + classLabel) % classes === 0) {
                        featureValue = 0.8 + Math.random() * 0.2;
                    } else if ((j + classLabel) % classes === 1) {
                        featureValue = 0.6 + Math.random() * 0.2;
                    } else if ((j + classLabel) % classes === 2) {
                        featureValue = 0.3 + Math.random() * 0.2;
                    } else {
                        featureValue = Math.random() * 0.2;
                    }
                    
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                validationData.push({ input, output });
            }
        }
        
        // Generate noisy classification data prone to overfitting
        function generateNoisyClassificationData(trainSamples, valSamples, dataModel) {
            const features = dataModel.features;
            const classes = dataModel.classes;
            const noiseLevel = dataModel.noiseLevel || 0.25;
            
            // Generate training data with high noise
            for (let i = 0; i < trainSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                // Only the first 3 features are truly informative
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    if (j < 3) {
                        // Informative features
                        if (j === classLabel % 3) {
                            featureValue = 0.8 + Math.random() * 0.2;
                        } else {
                            featureValue = Math.random() * 0.3;
                        }
                    } else {
                        // Non-informative features (pure noise)
                        featureValue = Math.random();
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                // Create one-hot encoded output
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                trainingData.push({ input, output });
            }
            
            // Generate validation data with same pattern but different noise
            for (let i = 0; i < valSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    if (j < 3) {
                        // Informative features
                        if (j === classLabel % 3) {
                            featureValue = 0.8 + Math.random() * 0.2;
                        } else {
                            featureValue = Math.random() * 0.3;
                        }
                    } else {
                        // Non-informative features (pure noise)
                        featureValue = Math.random();
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                validationData.push({ input, output });
            }
        }
        
        // Generate complex multi-class data
        function generateComplexMultiClassData(trainSamples, valSamples, dataModel) {
            const features = dataModel.features;
            const classes = dataModel.classes;
            const noiseLevel = dataModel.noiseLevel || 0.2;
            
            // Generate training data with complex patterns
            for (let i = 0; i < trainSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                // Create complex feature interactions
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    // Different classes have different feature interactions
                    if (classLabel < classes / 2) {
                        // First half of classes: XOR-like patterns
                        if ((j % 3 === 0 && j % 2 === 0) || (j % 3 !== 0 && j % 2 !== 0)) {
                            featureValue = (classLabel % 2 === 0) ? 0.8 + Math.random() * 0.2 : Math.random() * 0.3;
                        } else {
                            featureValue = (classLabel % 2 === 1) ? 0.8 + Math.random() * 0.2 : Math.random() * 0.3;
                        }
                    } else {
                        // Second half of classes: Cluster-like patterns
                        if (j % classes === classLabel % (classes / 2)) {
                            featureValue = 0.7 + Math.random() * 0.3;
                        } else if (Math.abs(j % classes - classLabel % (classes / 2)) === 1) {
                            featureValue = 0.5 + Math.random() * 0.3;
                        } else {
                            featureValue = Math.random() * 0.3;
                        }
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                // Create one-hot encoded output
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                trainingData.push({ input, output });
            }
            
            // Generate validation data
            for (let i = 0; i < valSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    if (classLabel < classes / 2) {
                        if ((j % 3 === 0 && j % 2 === 0) || (j % 3 !== 0 && j % 2 !== 0)) {
                            featureValue = (classLabel % 2 === 0) ? 0.8 + Math.random() * 0.2 : Math.random() * 0.3;
                        } else {
                            featureValue = (classLabel % 2 === 1) ? 0.8 + Math.random() * 0.2 : Math.random() * 0.3;
                        }
                    } else {
                        if (j % classes === classLabel % (classes / 2)) {
                            featureValue = 0.7 + Math.random() * 0.3;
                        } else if (Math.abs(j % classes - classLabel % (classes / 2)) === 1) {
                            featureValue = 0.5 + Math.random() * 0.3;
                        } else {
                            featureValue = Math.random() * 0.3;
                        }
                    }
                    
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                validationData.push({ input, output });
            }
        }
        
        // Generate adversarial data
        function generateAdversarialData(trainSamples, valSamples, dataModel) {
            const features = dataModel.features;
            const classes = dataModel.classes;
            const noiseLevel = dataModel.noiseLevel || 0.15;
            const adversarialRatio = dataModel.adversarialRatio || 0.2;
            
            // Generate clean data first
            const cleanTrainSamples = Math.floor(trainSamples * (1 - adversarialRatio));
            const adversarialTrainSamples = trainSamples - cleanTrainSamples;
            
            // Generate clean training data
            for (let i = 0; i < cleanTrainSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                // Generate features
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    // Simple cluster pattern
                    if (j % classes === classLabel) {
                        featureValue = 0.8 + Math.random() * 0.2;
                    } else {
                        featureValue = Math.random() * 0.3;
                    }
                    
                    // Add noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                // Create one-hot encoded output
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                trainingData.push({ input, output, isAdversarial: false });
            }
            
            // Generate adversarial examples
            for (let i = 0; i < adversarialTrainSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const targetLabel = (classLabel + 1) % classes; // Target a different class
                const input = [];
                
                // Generate base features for the original class
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    // Simple cluster pattern
                    if (j % classes === classLabel) {
                        featureValue = 0.8 + Math.random() * 0.2;
                    } else {
                        featureValue = Math.random() * 0.3;
                    }
                    
                    // Add normal noise
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    
                    // Add adversarial perturbation: push feature toward target class
                    if (j % classes === targetLabel) {
                        featureValue += 0.2 + Math.random() * 0.2; // Push up
                    }
                    if (j % classes === classLabel) {
                        featureValue -= 0.2 + Math.random() * 0.1; // Push down
                    }
                    
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                // The true label is still the original class, not the target
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                trainingData.push({ input, output, isAdversarial: true });
            }
            
            // Generate validation data (all clean)
            for (let i = 0; i < valSamples; i++) {
                const classLabel = Math.floor(Math.random() * classes);
                const input = [];
                
                for (let j = 0; j < features; j++) {
                    let featureValue;
                    
                    if (j % classes === classLabel) {
                        featureValue = 0.8 + Math.random() * 0.2;
                    } else {
                        featureValue = Math.random() * 0.3;
                    }
                    
                    featureValue += (Math.random() * 2 - 1) * noiseLevel;
                    featureValue = Math.max(0, Math.min(1, featureValue));
                    
                    input.push(featureValue);
                }
                
                const output = new Array(classes).fill(0);
                output[classLabel] = 1;
                
                validationData.push({ input, output });
            }
            
            // Shuffle training data to mix adversarial and clean examples
            trainingData = shuffleArray(trainingData);
        }
        
        // Utility function to shuffle array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
        
        // Forward pass through the network
        function forwardPass(input) {
            // Set input layer activations
            for (let i = 0; i < network.layers[0].size; i++) {
                network.activations[0][i] = input[i];
            }
            
            // Process activation function selection
            const activationFnSelect = document.getElementById('activation-fn');
            const activationFnName = activationFnSelect ? activationFnSelect.value : 'sigmoid';
            const activationFn = activationFunctions[activationFnName];
            
            // Process each layer
            for (let l = 1; l < network.layers.length; l++) {
                const layerSize = network.layers[l].size;
                const prevLayerSize = network.layers[l - 1].size;
                
                // For each node in current layer
                for (let j = 0; j < layerSize; j++) {
                    let sum = network.biases[l - 1][j];
                    
                    // Sum weighted inputs from previous layer
                    for (let i = 0; i < prevLayerSize; i++) {
                        sum += network.activations[l - 1][i] * network.weights[l - 1][i][j];
                    }
                    
                    // Store pre-activation value
                    network.preActivations[l][j] = sum;
                    
                    // Apply activation function
                    network.activations[l][j] = activationFn.forward(sum);
                }
            }
            
            // Return output layer activations
            return network.activations[network.layers.length - 1];
        }
        
        // Calculate loss for a single sample (cross entropy)
        function calculateLoss(predicted, target) {
            let loss = 0;
            for (let i = 0; i < predicted.length; i++) {
                // Prevent log(0) with small epsilon
                const p = Math.max(predicted[i], 1e-15);
                loss += target[i] * Math.log(p);
            }
            return -loss;
        }
        
        // Calculate accuracy for classification
        function calculateAccuracy(predicted, target) {
            const predictedClass = predicted.indexOf(Math.max(...predicted));
            const targetClass = target.indexOf(Math.max(...target));
            return predictedClass === targetClass ? 1 : 0;
        }
        
        // Backpropagation
        function backpropagation(input, target) {
            // Forward pass
            forwardPass(input);
            
            // Process activation function selection
            const activationFnSelect = document.getElementById('activation-fn');
            const activationFnName = activationFnSelect ? activationFnSelect.value : 'sigmoid';
            const activationFn = activationFunctions[activationFnName];
            
            // Initialize arrays to store deltas
            const deltas = [];
            for (let l = 0; l < network.layers.length; l++) {
                deltas.push(new Array(network.layers[l].size).fill(0));
            }
            
            // Calculate output layer deltas (assuming cross-entropy loss and softmax output)
            const outputLayer = network.layers.length - 1;
            for (let i = 0; i < network.layers[outputLayer].size; i++) {
                // For cross entropy loss, delta is simply (prediction - target)
                deltas[outputLayer][i] = network.activations[outputLayer][i] - target[i];
            }
            
            // Backpropagate deltas to hidden layers
            for (let l = outputLayer - 1; l > 0; l--) {
                for (let i = 0; i < network.layers[l].size; i++) {
                    let delta = 0;
                    
                    // Sum up deltas from next layer
                    for (let j = 0; j < network.layers[l + 1].size; j++) {
                        delta += deltas[l + 1][j] * network.weights[l][i][j];
                    }
                    
                    // Multiply by derivative of activation function
                    delta *= activationFn.backward(network.preActivations[l][i]);
                    
                    deltas[l][i] = delta;
                }
            }
            
            // Calculate gradients for weights and biases
            for (let l = outputLayer; l > 0; l--) {
                for (let i = 0; i < network.layers[l].size; i++) {
                    // Bias gradient is simply the delta
                    network.gradients.biases[l - 1][i] = deltas[l][i];
                    
                    // Calculate weight gradients
                    for (let j = 0; j < network.layers[l - 1].size; j++) {
                        network.gradients.weights[l - 1][j][i] = deltas[l][i] * network.activations[l - 1][j];
                    }
                }
            }
            
            return calculateLoss(network.activations[outputLayer], target);
        }